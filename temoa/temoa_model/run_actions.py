"""
Basic-level atomic functions that can be used by a sequencer, as needed
"""

from logging import getLogger
from pathlib import Path
from sys import stderr as SE
# Written by:  J. F. Hyink
# jeff@westernspark.us
# https://westernspark.us
# Created on:  11/15/23
from time import time
from typing import Iterable, Tuple

from pyomo.environ import DataPortal, Suffix, Var, Constraint, value, UnknownSolver, SolverFactory
from pyomo.opt import SolverResults

from temoa.temoa_model.pformat_results import pformat_results
from temoa.temoa_model.temoa_model import TemoaModel

logger = getLogger(__name__)


def build_instance(dat_files: Iterable[Path], model_name=None) -> TemoaModel:
    """
    Build a Temoa Instance from data
    :param model_name: Optional name for this instance
    :param dat_files: A list of .dat files to construct from [PRESUMABLY 1 file!]
    :return: a built TemoaModel
    """
    model = TemoaModel()
    model_data = DataPortal(model=model)
    for fname in dat_files:
        if fname[-4:] != '.dat':
            logger.error('Attempted to load data from file %d which is not a .dat file', fname)
            raise TypeError('file loading error occurred, see log')
        logger.debug('Started loading the DataPortal from the .dat file')
        model_data.load(filename=fname)
        logger.debug('Finished reading the .dat file')

    # TODO:  Look at this.  There is likely a better way to get the dual than using Suffix (?)
    model.dual = Suffix(direction=Suffix.IMPORT)
    # self.model.rc = Suffix(direction=Suffix.IMPORT)
    # self.model.slack = Suffix(direction=Suffix.IMPORT)

    logger.info('Started creating model instance from data')
    instance = model.create_instance(model_data)
    logger.info('Finished creating model instance from data')

    # gather some stats...
    c_count = 0
    v_count = 0
    for constraint in instance.component_objects(ctype=Constraint):
        c_count += len(constraint)
    for var in instance.component_objects(ctype=Var):
        v_count += len(var)
    logger.info("model built...  Variables: %d, Constraints: %d", v_count, c_count)
    return instance


def solve_instance(instance: TemoaModel, solver_name, keep_LP_files: bool) -> Tuple[TemoaModel, SolverResults]:
    """
    Solve the instance and return a loaded instance
    :param keep_LP_files: Flag whether LP files generated by solver action should be retained
    :param solver: The name of the solver to request from the SolverFactory
    :param instance: the instance to solve
    :return: loaded instance
    """
    # TODO:  Type the solver in signature
    begin = time()
    duration = lambda: time() - begin
    result = None

    # QA the solver name and get a handle on solver
    if not solver_name:
        logger.error('No solver specified in solve sequence')
        raise TypeError('Error occurred during solve, see log')
    optimizer = SolverFactory(solver_name)
    if isinstance(optimizer, UnknownSolver):
        logger.error('Failed to create a solver instance for name: %s.  Check name and availability on this system',
                     solver_name)
        raise TypeError('Failed to make Solver instance.  See log.')
    if solver_name not in {'cbc', 'neos', 'cplex'}:
        logger.warning('Attempting to use solver named %d which does not have (optional?) options set')

    # yield 'Solving.'
    SE.write('[        ] Solving.');
    SE.flush()

    try:
        logger.info('Starting the solve process using %s solver on model %s', solver_name, instance.name)
        if solver_name == 'neos':
            raise NotImplementedError
            # result = options.optimizer.solve(instance, opt=options.solver)
        else:
            if solver_name == 'cbc':
                # Solver options. Reference: https://genxproject.github.io/GenX/dev/solver_configuration/
                optimizer.options["dualTolerance"] = 1e-6
                optimizer.options["primalTolerance"] = 1e-6
                optimizer.options["zeroTolerance"] = 1e-12
                optimizer.options["crossover"] = 'off'

            elif solver_name == 'cplex':
                # Note: these parameter values are taken to be the same as those in PyPSA (see: https://pypsa-eur.readthedocs.io/en/latest/configuration.html)
                optimizer.options["lpmethod"] = 4  # barrier
                optimizer.options["solutiontype"] = 2  # non basic solution, ie no crossover
                optimizer.options["barrier convergetol"] = 1.e-5
                optimizer.options["feasopt tolerance"] = 1.e-6

            # TODO: still need to add gurobi parameters.

            result = optimizer.solve(instance, suffixes=['dual'],  # 'rc', 'slack'],
                                     keepfiles=keep_LP_files,
                                     symbolic_solver_labels=keep_LP_files)
            logger.info('Solve process complete')
            logger.debug('Solver results: \n %s', result)
        # yield '\t\t\t\t\t\t[%8.2f]\n' % duration()
        SE.write('\r[%8.2f]\n' % duration())

    except Exception as model_exc:
        # yield "Exception found in solve_temoa_instance\n"
        SE.write("Exception found in solve_temoa_instance\n")
        # yield str(model_exc) + '\n'
        SE.write(str(model_exc))
        raise model_exc

    # TODO:  What is this transformation??  I think this should change and just work
    #        with termination condition, which is all that appears to be needed downstream
    instance.solutions.store_to(result)
    return instance, result


def handle_results(instance: TemoaModel, results, options):
    # ... print the easier-to-read/parse format
    msg = '[        ] Calculating reporting variables and formatting results.'
    # yield 'Calculating reporting variables and formatting results.'
    SE.write(msg);
    SE.flush()
    # instance.solutions.store_to(self.result)
    begin = time()
    duration = lambda: time() - begin
    formatted_results = pformat_results(instance, results, options)
    # yield '\t[%8.2f]\n' % duration()
    SE.write('\r[%8.2f]\n' % duration())

    # SO.write( formatted_results.getvalue() )

    if formatted_results.getvalue() == 'No solution found.':
        SE.write(formatted_results.getvalue() + '\n')
    # normal (non-MGA) run will have a TotalCost as the OBJ:
    if hasattr(instance, 'TotalCost'):
        logger.info("TotalCost value: %0.2f", value(instance.TotalCost))
    # MGA runs should have either a FirstObj or SecondObj
    if hasattr(instance, 'FirstObj'):
        logger.info("MGA First Obj value: %0.2f", value(instance.FirstObj))
    elif hasattr(instance, 'SecondObj'):
        logger.info("MGA Second Obj value: %0.2f", value(instance.SecondObj))
    return


# def parse_args() -> argparse.Namespace:
#     """Parse arguments specfied from command line or in config file."""
#
#     parser = argparse.ArgumentParser()
#     # parser.prog = path.basename(argv[0].strip('/'))
#     logger.debug('Parsing CLA for information...')
#
#     # parser.add_argument('dot_dat', type=str, nargs='*',
#     #                     help='AMPL-format data file(s) with which to create a model instance. '
#     #                          'e.g. "data.dat"')
#     #
#     # parser.add_argument('--path_to_logs',
#     #                     help='Path to where debug logs will be generated by default. See folder debug_logs in data_files.',
#     #                     action='store', dest='path_to_logs', default=re.sub('temoa_model$', 'data_files', dirname(
#     #         abspath(__file__))) + os.sep + "debug_logs")
#
#     parser.add_argument('--config', help='Path to file containing configuration information.', action='store',
#                         dest='config', default=None)
#
#     # parser.add_argument('--solver', help="Which backend solver to use.  See 'pyomo --help-solvers' for a list "
#     #                                      'of solvers with which Pyomo can interface.  The list shown here is '
#     #                                      'what Pyomo can currently find on this system.  [Default: {}]'.format(
#     #     default_solver), action='store', choices=sorted(available_solvers), dest='solver', default=default_solver)
#
#     options = parser.parse_args()
#     return options
#
#
#     options.neos = False
#
#     # Can't specify keeping the LP file without config file, so set this
#     # attribute to false
#     options.keepPyomoLP = False
#
#     # If the user specifies the config flag, then call TemoaConfig and overwrite
#     # the argument parser above.
#     if options.config:
#         # TODO:  Change this out to proper boolean
#         config_flag = 1  # flag indicates config file was used.
#         try:
#             temoa_config = TemoaConfig(d_solver=default_solver)
#             temoa_config.build(config=options.config)
#             SE.write(repr(temoa_config))
#             options = temoa_config
#             SE.write('\nPlease press enter to continue or Ctrl+C to quit.\n')
#             # raw_input() # Give the user a chance to confirm input
#             if options.abort_temoa:
#                 return
#         except KeyboardInterrupt:
#             SE.write('\n\nUser requested quit.  Exiting Temoa ...\n')
#             raise SystemExit()
#     else:
#         config_flag = 0  # flag indicates config file was not used.
#
#     s_choice = str(options.solver).upper()
#     SE.write('Notice: Using the {} solver interface.\n'.format(s_choice))
#     SE.flush()
#
#     SE.write("Continue Operation? [Press enter to continue or CTRL+C to abort]\n")
#     SE.flush()
#
#     # TODO:  this remnant is a horrible hack that needs to be changed to inspect for myopic mode vs. name matching
#     if 'config_sample_myopic' not in options.file_location:
#         #
#         pass
#         # TODO: below confirmation is temp commented out to speed development
#         # input()  # Give the user a chance to confirm input
#
#
#     return options, config_flag